#!/usr/bin/php -q
<?php

/**
 * Phake Shell class
 *
 * @package phake
 * @author Brent Kirby
 **/


class Phake{
	
	/**
	 * Holds all class wide variables.
	 *
	 * @var string
	 * @access public
	 **/
	public $_class_vars;
	
	
	/**
	 * Holds all of the current shell vars (input minus flags)
	 *
	 * @var string
	 * @access public
	 **/
	public $_vars;
	
	/**
	 * Holds all of the current shell flags.
	 * Single Flags (-f) are used to set variables.
	 * Multi line flags are methods to be called during class construction.
	 *
	 * @var string
	 * @access private
	 **/
	private $_flags;
	
	/**
	 * The class to be loaded.
	 *
	 * @var string
	 * @access private
	 **/
	private $_object;
	
	/**
	 * The method to be invoked.
	 *
	 * @var string
	 * @access private
	 **/
	private $_method;
	
	/**
	 * Holds a list of any private methods that need to be invoked.
	 *
	 * @var string
	 **/
	var $private_methods;
	
	/**
	 * Namespaces (paths) to the object.
	 *
	 * @var string
	 **/
	private $_namespaces;
	
	/**
	 * Input from the shell
	 *
	 * @var stream
	 * @access protected
	 **/
	protected $shell_in;
	
	/**
	 * Output to the shell.
	 *
	 * @var stream
	 * @access protected
	 **/
	protected $shell_out;
	
	/**
	 * Shell Constructor
	 *
	 * @return void
	 * @param array $args are all of the arguments passed to the script.
	 **/
	
	public final function __construct($args = array()){
		
		$this->shell_in  = fopen('php://stdin', 'r');
		$this->shell_out = fopen('php://stdout', 'w');
		
		array_shift($args);
		
		if(!empty($args)){
			
			$this->_flags 			= array();
			$this->_class_vars  	= array();
			$this->_vars 			= array();
			$this->_private_methods	= array();
			
			$this->process_args($args);
			
			if(!empty($this->_object)){
				$this->run_task();
			}else{	
				$this->run_internal_task();	
			}
			
		}else{
			$this->help();
		}
	}
	
	
	/**
	 * Output text to the console.
	 *
	 * @return void
	 * @param string $string The text to output
	 * @access public
	 **/
	protected function output($string, $newline = true){
		$append = ($newline == true)? "\n" : "";
		fwrite($this->shell_out, $string . $append);
	}
	
	
	/**
	 * Output and exit
	 *
	 * @return void
	 * @param string $string The text to output
	 * @access public
	 **/
	protected function fail($string, $newline = true){
		$append = ($newline == true)? "\n" : "";
		fwrite($this->shell_out, $string . $append);
		exit();
	}
	
	
	/**
	 * Adds a heading to the next line.
	 *
	 * @return void
	 **/
	protected function add_heading(){
		$this->output("\n________________________________________\n");
	}
	
	/**
	 * Input text from the console.
	 *
	 * @return void
	 * @param string $string The text to output (question)
	 * @access public
	 **/
	protected function input($string){
		$this->output($string." ", false);
		$result = fgets($this->shell_in);
		if($result == false) exit();
		$result = trim($result);
		return $result;
	}
	
	/**
	 * Process all incoming values.
	 *
	 * @return void
	 * @param $args are the args passed from the constructor
	 **/
	private function process_args($args){
		
		$is_internal = true;
		
		foreach($args as $arg){

			if(strpos($arg, ":")){
				
				// We are processing the external commands now.
				$is_internal = false;
				
				// Get the class, command, and any namespaces.
				$options = explode(":", $arg);
				$this->_method 	  = array_pop($options);
				$this->_object 	  = array_pop($options);
				$this->_namespace = implode(DIRECTORY_SEPARATOR, $options);
			
			}
			
			else if(substr($arg, 0, 2) == "--"){
				$val = str_replace("--", "", $arg);
				($is_internal == true)? $this->_private_methods[] = $val : $this->_flags[] = $val;
			}
			
			else if(substr($arg, 0,1) == "-"){
				$items = explode("=", $arg);
				$items[0] = str_replace("-", "", $items[0]);
				$this->_class_vars[$items[0]] = $items[1];
			}			
			
			else{
				
				// We are processing the external commands now.
				$is_internal = false;
				
				$this->_vars[] = $arg;
			}
			
			
		}
		
		if(empty($this->_object)){
			if(!empty($this->_vars)) $this->_object = $this->_vars[0];
		}

	
	}
	
	/**
	 * Run an external task
	 *
	 * @return void
	 * @access private
	 **/
	
	
	private function run_task(){
		
		$class_name = $this->camelize($this->_object);
		$class = new $class_name();

		// Run any functions called from command line first.
		
		// Internal
		foreach($this->_private_methods as $pm){
			if(method_exists($class, $flag)){
				call_user_func(array($class, $flag));
			}else{
				$this->output("Invalid flag/action '--$flag'");
				exit();
			}
		}
		
		// External
		foreach($this->_flags as $flag){
			
			if(method_exists($class, $flag)){
				if( is_callable(array($class, 'init')) ) call_user_func(array($class,'init'));
				call_user_func(array($class, $flag));
				$passed_locals = true;
			}else{
				$this->output("Invalid flag/action '--$flag'");
				exit();
			}
		}
		
		// Set props
		if(property_exists($class, 'flags')) $class->flags = $this->_class_vars;
		if(property_exists($class, 'vars')) $class->vars = $this->_vars;

		if(is_callable(array($class, $this->_method))){
			call_user_func(array($class, $this->_method));
		}else{
			if(!isset($passed_locals)) $this->help();
		}
		
		
		unset($class);
	}
	
	/**
	 * undocumented function
	 *
	 * @return void
	 **/
	private function run_internal_task(){
		foreach($this->_private_methods as $method) call_user_func(array($this, $method));
	}
	
	
	/**
	 * Convert an underscored class name or method to CamelCase
	 *
	 * @return string
	 * @param string $str: The input string (underscored)
	 **/
	private function camelize($str){
		return preg_replace('/(^|_)(.)/e', "strtoupper('\\2')", strval($str));
	}
	
	/**
	 * Gets class vars by name
	 *
	 * @return void
	 **/
	public function __get($var){
		return $this->class_vars[$var];
	}
	
	/**
	 * Output class help information
	 *
	 * @return void
	 **/
	public function help(){
		
		$this->add_heading();
		$this->output("Phake (PHP Rake) Help:\n");

		$this->add_heading();
		
	}
	
	
}





// Load phakefile if any
try{
	include_once(getcwd()."/phakefile");
	foreach($task_paths as $path){
		foreach(glob($root_path."/".$path."/*.php") as $file){
			include_once($file);
		}
	}
}catch(Exception $e){}


// Start execution
$phake = new Phake($argv);

?>
